# Academic-Projects

| Project Name  | Course        | Language | Description |
| :-------------: |:-------------:| :--------:| :-----------:|
| Grade Several Multiple-Choice Exam| Computer Science 1/ CIS 150 | C++ | A program to grade several multiple-choice exams. The exam has 20 questions, each answered with a letter in the range of ‘a’ through ‘f’. The answers key is declared in the program as constant of type string. An example of answer key is “abcdefabcdefabcdefab”. Program should work for any other answer key. |
| PowerBall_Lottery | Computer Science 2/ CIS 200 | C++ | A program that allows a user to pretend to play the PowerBall lottery - https://www.powerball.com/ (Links to an external site.) The simulation must track total $s spent, total $s won and calculate the net loss. The user should be asked if they want to select #s themselves or buy random tickets.  If they select numbers, ensure no duplicate white numbers are entered.  Allow them to pick #s for a single ticket, then generate a random winning ticket and display the results, including totals. If they ask to purchase random tickets, ask how many tickets and if they want to see all tickets or just winning tickets.  Generate the random tickets and display the results as requested, including totals. Continue asking the user if they want to pick #s or buy random tickets until they ask to quit. |
| Car Racing-OOProgramming | Computer Science 2/ CIS 200 | C++ | A program that simulates cars racing and allows users to bet on the races. Prompt the user to enter details needed to create 2 instances of the Car. Ask the user to bet on which car will win the race ( use the overridden << method to display car details ), ensure the bet is between 1 and the amount of money the user has currently. Allow the user to keep creating cars to race until they are done or out of money. |
| Anagram | Data Structures and Algorithms for Software Engineers/ CIS 3501 | C++ | Two words are anagrams of each other if one can be produced by a reordering of letters of theother. For example, “resistance” and “ancestries” are a pair of anagrams. Another anagram pair is“admirer” and “married”. Each anagram forms an equivalence relation since it is: • reflexive (each word is an anagram of itself) • symmetric (if w1 is an anagram of w2 then w2 is an anagram of w1) • transitive (f w1 is an anagram of w2 and w2 is an anagram of w3 then w1 is an anagram of w3). Given a list of words Program is going to separate the words into equivalence classes and list the classes that have the greatest number of members in lexicographical order. Input: The input will consist of a single test case. The first line contains 2 integers 0 < m, n (separated by a single space) which indicates the number of words to consider and the number of classes to print out. The next m lines will be a single word composed of lowercase alphabetical characters. Input should be read in from a file, named words.txt. Output: Output the n largest anagram equivalence classes. If there are less than n classes, then output them all. Sort the classes by decreasing size. You can break ties lexicographically by the lexicographically smallest element. For each class output, print its size and its member words. Sort the member words lexicographically and print equal words only once.|
| BST |  Data Structures and Algorithms for Software Engineers/ CIS 3501 | C++ | A binary search tree is a tree in which the data at any non-leaf node is larger the data in the nodes in its left subtree and smaller than the data in the nodes in its right subtree. Input: The input will consist of a single binary tree of non-negative integers. The format of the file will besimilar to how an array would hold binary tree information. The first line indicates the root and its children, the next line is the left child of the root, the third line is the right child of the root and so on. The formula would generally follow the format that for any give node k, its children are at 2k (left child) and 2k + 1 (right child), assuming we number our lines starting at 1, and k is used as such a number. For example, if we want to know the right child of the node of line 4, we calculate 2(4) + 1, which is 9. So line 9 would hold that value. Use the value -1 to indicate that a child doesn’t exist. Input should be read in from a file, tree.txt. Output: The output will consist of 1 or 4 lines of output, depending: Is this a binary search tree? Print Yes or no. Pre-order traversal, In-order traversal, Post-order traversal. If the tree is not a binary search tree, you only print “No”. If the tree is a binary search tree, print out the pre, in, and post-order traversals on the next three lines. |
| Sorting Time Comparision |  Data Structures and Algorithms for Software Engineers/ CIS 3501 | C++ | Implement from scratch both QuickSort, and InsertionSort.  Compare their running times on sets of integers of size 250, 500, 750, 1000, 2500.  You can generate these sets using the language’s built-in Randomization techniques. Which appears to perform better as the number of integers increases?  Run each algorithm at least 5 times on each set size (five times for set size of 250, five times for 500, etc. – for EACH algorithm). |
| Graph_Detect_Cycle |  Data Structures and Algorithms for Software Engineers/ CIS 3501 | C++ | To detect if there is any cycle in the undirected graph or not. |
